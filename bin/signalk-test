#!/usr/bin/env node

/*
 * Copyright 2015 Teppo Kurki <teppo.kurki@iki.fi>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/

var signalk_client = require('signalk-client');
var isDelta = signalk_client.isDelta;
var isHello = signalk_client.isHello;

var Spinner = require('cli-spinner').Spinner;

var schema = require('signalk-schema')

var client = new signalk_client.Client();


function onConnect() {
  console.log("Connected");
}

function onDisconnect() {}

var args = process.argv.slice(2);

Spinner.setDefaultSpinnerString('|/-\\');
var spinner = new Spinner();
var spinning = false;
var lastMsgReceived = 0;

var options = {
  onData: function(data) {
    if (isHello(data)) {
      console.log("Version:" + data.version);

    }
    if (isDelta(data)) {
      lastMsgReceived = new Date().getTime();
      var validationResult = schema.validateDelta(data);
      if (!validationResult.valid) {
        console.log(JSON.stringify(data));
        validationResult.errors.forEach(function(error) {
          console.error(error.message + "\n " + error.dataPath + "\n " + error.schemaPath)
        });
      }
    }
  },
  onConnect: function() {
    console.log("Connected");
  },
  onDisconnect: function() {
    console.log("Disconnected");
  },
  onError: function(error) {
    console.log(error);
  }
};

if (args.length === 2) {
  options.host = args[0];
  options.port = args[1];
}

client.connect(options);


function hasFreshData() {
  return result = new Date().getTime() - lastMsgReceived < 500;
}

setInterval(function() {
  if (hasFreshData() && !spinning) {
    spinner.start();
    spinning = true;
  }
  if (spinning && !hasFreshData()) {
    spinner.stop();
    spinning = false;
  }
}, 200);
